---
title: "Colorado temperature analysis using gstat"
output: html_document
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(comment = NA, tidy = TRUE)
```

## Colorado spring temperature data
These data were originally part of the `fields` package's `COmonthlyMet` dataset.
```{r, download_data}
rm(list=ls())
load("CO-temp-data.RData")
ls()
```

Our goal is to create a complete prediction surface of minimum spring temperature with associated estimates of uncertainty. 

We begin by loading the necessary packages.

```{r, load_packages, message=FALSE}
## Some of the spatial projection protocol used by rgdal and dependent packages is 
## in flux. Use the option below until package development settles down.
## For more information see http://rgdal.r-forge.r-project.org/articles/PROJ6_GDAL3.html
options("rgdal_show_exportToProj4_warnings"="none")

library(spBayes)
library(MBA)
library(gstat)
library(raster)
library(leaflet)
library(sp)
```

Next, set up a `leaflet` basemap to help visualize the data and model output. We'll make heavy use of the pipe operator `%>%` to reduce clutter.

```{r, leaflet_basemap}
blue.red <-  c("#2c7bb6","#abd9e9","#ffffbf","#fdae61","#d7191c")

base.map <- leaflet(width="100%") %>%
    addProviderTiles("Stamen.Terrain", group="Terrain") %>%
    addProviderTiles("Esri.WorldImagery", group="Satellite") %>%
    addLayersControl(
        baseGroup = c("Terrain", "Satellite"),
        options = layersControlOptions(collapsed = FALSE)
    )
```

Take a look at station locations and mean minimum spring temperatures across Colorado. This code below produces a clickable dynamic map.
```{r, map_stations}
pal <- colorNumeric(blue.red, domain = temp)

base.map %>%
    addCircleMarkers(lng = coords[,1], lat = coords[,2], col = pal(temp), stroke = FALSE, radius = 5, fillOpacity = 0.9, popup=paste("Mean min temp:",round(temp,1))) %>%
    addLegend("bottomright", pal = pal, values = temp, opacity = 0.9, title = "Temperature C")
    
```

### Fit a non-spatial regression
Consider the non-spatial regression and a little exploratory data analysis (EDA).

```{r, fit_lm}
lm.obj <- lm(temp ~ lon + lat, data=coords)
summary(lm.obj)
```

We'll reproject the geographic coordinates (i.e., longitude and latitude) to a coordinate system that provides a bit more intuition about distance and reduces spatial distortion. Here we selected Universal Transverse Mercator (UTM) coordinate system. To improve interpretation we convert the UTM distance units from meters to kilometers.

```{r, reproject_coords}
##Promote coords to a sp package SpatialPoints object.
coordinates(coords) <- ~lon+lat
proj4string(coords) <- "+proj=longlat +datum=WGS84"
coords.utm <- spTransform(coords, CRS("+proj=utm +zone=13 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
coords.utm <- coordinates(coords.utm)/1000

##Changes the sp object coords back to a matrix for later.
coords <- coordinates(coords)
```

Next let's take a look at the regression model residuals, assess their spatial independence, and start thinking about variogram and covaraince parameters.
```{r, plot_variograms, fig.align="center", fig.width=10, message=FALSE}
d.max <- max(iDist(coords.utm))
d.max

v.temp <- variogram(temp~1, coords=coords.utm, data=temp)

v.resid <- variogram(temp~1, coords=coords.utm, data=resid(lm.obj))

par(mfrow=c(1,2))
plot(v.temp, xlab="Distance (km)")
plot(v.resid, xlab="Distance (km)")
```

It is also very helpful to create an interpolated surface of the model residuals to further assess spatial structure and potentially identify missing covariates.

```{r, map_residuals}
resid.surf <- mba.surf(cbind(coords, resid(lm.obj)), no.X=200, no.Y=200, extend=TRUE, sp=TRUE)$xyz.est

proj4string(resid.surf) <- "+proj=longlat +datum=WGS84"

resid.surf <- raster(resid.surf)

pal <- colorNumeric(blue.red, values(resid.surf), na.color = "transparent")

base.map %>%
    addRasterImage(resid.surf, colors = pal, opacity = 0.75, group="Regression residuals") %>%
    addLegend("bottomright", pal = pal, values = values(resid.surf), opacity = 0.75, title = "<center>Regression<br> residuals</center>") %>%
    addLayersControl(
        baseGroup = c("Terrain", "Satellite"),
        overlayGroups = c("Regression residuals"),
        options = layersControlOptions(collapsed = FALSE)
    )
```

### Fit some spatial regression models
There's substantial evidence of residual spatial structure, so let's fit some models with spatially-structured random effects. 

